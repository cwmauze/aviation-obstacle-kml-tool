<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KML Obstacle Overlay Generator</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        :root {
            color-scheme: dark;
            --bg: #18191a; --card: #242526; --text: #e4e6eb; --border: #3e4042;
            --primary: #478df5; --secondary: #3a3b3c; --danger: #fb6161;
            --success: #28a745; --earth: #2d81ff; --link: #a3c7ff; --dispatch: #f39c12;
            --header-sep: rgba(255, 255, 255, 0.1);
            --glass: rgba(30, 31, 32, 0.98);
            --section-bg: rgba(0,0,0,0.15);
            --input-bg: #3a3b3c;
        }
        [data-theme="light"] {
            color-scheme: light;
            --bg: #f0f2f5; --card: #ffffff; --text: #1c1e21; --border: #dadde1;
            --primary: #1a73e8; --secondary: #e4e6eb; --danger: #fa3e3e;
            --link: #1a73e8; --dispatch: #f39c12;
            --header-sep: rgba(0, 0, 0, 0.1);
            --glass: rgba(255, 255, 255, 0.95);
            --section-bg: #f7f8fa; 
            --input-bg: #ffffff; 
        }

        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; margin: 20px; background: var(--bg); color: var(--text); transition: background 0.3s; }
        .container { max-width: 700px; margin: auto; background: var(--card); padding: 30px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); position: relative; }
        
        /* Headers & Links */
        .version-subtitle { font-size: 11px; color: var(--link); margin-top: 4px; margin-bottom: 20px; display: inline-block; font-weight: normal; cursor: pointer; text-decoration: underline; }
        .project-link { font-size: 11px; color: #90949c; margin-left: 15px; text-decoration: underline; cursor: pointer; transition: color 0.2s; }
        .project-link:hover { color: var(--link); }
        .header-row { display: flex; justify-content: space-between; align-items: flex-start; border-bottom: 2px solid var(--border); padding-bottom: 10px; margin-bottom: 20px; }
        h2 { margin: 0; color: var(--primary); line-height: 1; font-size: 22px; }
        
        /* Status Card */
        .session-status-card { background: var(--secondary); padding: 12px 15px; border-radius: 8px; border: 1px solid var(--border); font-size: 12px; margin-bottom: 20px; }
        .status-line { margin-top: 6px; display: flex; justify-content: space-between; align-items: center; }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; background: #555; display: inline-block; flex-shrink: 0; }
        .status-dot.loading { background: var(--dispatch); animation: dbPulse 1s infinite; }
        .status-dot.ready { background: var(--success); }
        .status-dot.error { background: var(--danger); }
        @keyframes dbPulse { 0% { opacity: 1; } 50% { opacity: 0.3; } 100% { opacity: 1; } }

        /* UI Grouping & Grid */
        .section-card { border: 1px solid var(--border); border-radius: 8px; padding: 15px 20px; margin-bottom: 15px; background: var(--section-bg); }
        .section-title { font-weight: 800; color: var(--primary); margin-bottom: 14px; text-transform: uppercase; font-size: 12px; letter-spacing: 0.8px; display: flex; justify-content: space-between; align-items: center; }
        .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        @media (max-width: 500px) { .grid-2 { grid-template-columns: 1fr; gap: 10px; } }
        
        .col-divider { border-right: 1px solid var(--border); padding-right: 20px; }
        @media (max-width: 500px) { .col-divider { border-right: none; padding-right: 0; border-bottom: 1px solid var(--border); padding-bottom: 15px; margin-bottom: 5px; } }

        label { display: block; font-weight: bold; color: var(--text); font-size: 12px; opacity: 0.9; margin-bottom: 4px; }
        input[type="number"], input[type="text"], select { width: 100%; height: 36px; padding: 8px 10px; background: var(--input-bg); color: var(--text); border: 1px solid var(--border); border-radius: 5px; box-sizing: border-box; font-size: 13px; font-family: inherit; }
        input[type="range"] { flex: 1; margin: 0 10px; cursor: pointer; background: transparent; }
        
        /* EFB Optimized Inline Controls */
        .inline-control { display: flex; align-items: center; justify-content: space-between; gap: 12px; background: var(--input-bg); padding: 10px 14px; border-radius: 8px; border: 1px solid var(--border); margin-bottom: 12px; min-height: 40px; }
        .inline-control label { margin: 0; font-weight: normal; font-size: 13px; }
        .inline-control input[type="color"] { width: 44px; height: 32px; padding: 0; border: 1px solid var(--border); background: none; cursor: pointer; border-radius: 6px; flex-shrink: 0; }
        .inline-control input[type="number"] { flex-shrink: 0; }
        
        .checkbox-group { display: flex; align-items: center; gap: 12px; padding: 8px 0; cursor: pointer; }
        .checkbox-group input { width: 22px; height: 22px; margin: 0; cursor: pointer; accent-color: var(--primary); }
        .checkbox-group label { margin: 0; font-weight: bold; font-size: 13px; cursor: pointer; }
        
        #facilityName { font-size: 11px; font-weight: bold; margin-top: 6px; min-height: 14px; text-transform: uppercase; }

        .btn-group { display: flex; gap: 12px; margin-top: 20px; }
        button.action { flex: 1; padding: 14px; color: white; border: none; border-radius: 6px; font-size: 14px; font-weight: bold; cursor: pointer; transition: 0.2s; }
        button.action span { display: block; font-size: 9px; font-weight: normal; opacity: 0.8; margin-top: 3px; }
        .btn-preview { background-color: #4a7ae6; }
        .btn-preview:hover { background-color: #3b66c4; }
        .btn-download { background-color: #4cae64; }
        .btn-download:hover { background-color: #3e9151; }
        
        /* New Stacked Button Styles & Grid */
        .btn-stacked { display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 4px; padding: 12px 8px; color: white; border: none; border-radius: 8px; cursor: pointer; transition: filter 0.2s; text-align: center; font-family: inherit; }
        .btn-stacked:hover { filter: brightness(0.9); }
        .btn-stacked svg { width: 20px; height: 20px; fill: none; stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; }
        .btn-stacked .btn-title { font-size: 15px; font-weight: bold; line-height: 1.2; margin-top: 2px; }
        .btn-stacked .btn-sub { font-size: 10px; font-weight: normal; opacity: 0.9; text-transform: uppercase; letter-spacing: 0.5px; }
        
        .btn-slate { background-color: #5c6e7a; }
        .btn-red { background-color: #cc544b; }

        .top-action-bar { display: flex; gap: 12px; margin-bottom: 20px; }
        .btn-flat { flex: 1; background: var(--secondary); border: 1px solid var(--border); color: var(--text); padding: 14px 10px; border-radius: 8px; font-size: 13px; font-weight: bold; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 8px; transition: all 0.2s; text-transform: uppercase; letter-spacing: 0.5px; box-shadow: 0 4px 6px rgba(0,0,0,0.15); }
        .btn-flat:hover { filter: brightness(1.15); transform: translateY(-1px); }
        .btn-flat svg { width: 24px; height: 24px; stroke: currentColor; fill: none; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; }
        .btn-flat.primary { color: var(--primary); border-color: rgba(71, 141, 245, 0.4); background: rgba(71, 141, 245, 0.08); }
        .btn-flat.primary:hover { background: rgba(71, 141, 245, 0.15); }
        
        .btn-flat.danger { color: var(--danger); border-color: rgba(251, 97, 97, 0.4); background: rgba(251, 97, 97, 0.08); }
        .btn-flat.danger:hover { background: rgba(251, 97, 97, 0.15); }

        .bracket-grid { display: grid; grid-template-columns: 1fr 3fr 1fr; gap: 12px; align-items: stretch; margin-top: 15px; }
        .bracket-center { display: flex; flex-direction: column; gap: 4px; justify-content: center; }
        @media (max-width: 600px) { 
            .bracket-grid { grid-template-columns: 1fr; gap: 10px; } 
            .bracket-grid .btn-stacked { padding: 12px; flex-direction: row; gap: 12px; } 
            .bracket-grid .btn-stacked svg { width: 20px; height: 20px; } 
            .bracket-grid .btn-stacked .btn-sub { display: none; } 
            .bracket-grid .btn-stacked .btn-title { margin-top: 0; }
        }

/* Segmented Control */
        .segmented-control { display: flex; align-items: stretch; background: var(--section-bg); border-radius: 8px; padding: 4px; margin-bottom: 15px; border: 1px solid var(--border); gap: 2px; }
        .segmented-control input[type="radio"] { display: none; }
        .segmented-control label { flex: 1; display: flex; align-items: center; justify-content: center; text-align: center; padding: 12px 4px; margin: 0; font-size: 11px; font-weight: bold; color: var(--text); cursor: pointer; border-radius: 6px; transition: 0.2s; opacity: 0.8; text-transform: uppercase; letter-spacing: 0.5px; box-sizing: border-box; border: 1px solid transparent; position: relative; }
        .segmented-control label:not(:last-of-type)::after { content: ""; position: absolute; right: -2px; top: 15%; height: 70%; width: 1px; background: rgba(128, 128, 128, 0.4); z-index: 0; }
        .segmented-control input[type="radio"]:checked + label { background: var(--card); color: var(--primary); opacity: 1; box-shadow: 0 2px 6px rgba(0,0,0,0.3); border: 1px solid var(--border); z-index: 1; }
        .segmented-control input[type="radio"]:checked + label::after { display: none; }
        .segmented-control label:hover { opacity: 1; background: rgba(128, 128, 128, 0.1); }
        .segmented-control input[type="radio"]:checked + label:hover { background: var(--card); } /* Keeps the active tab looking solid */
        @media (max-width: 500px) { .segmented-control { flex-wrap: wrap; } .segmented-control label { flex: 1 1 40%; } .segmented-control label::after { display: none; } }

/* Modal Styles */
        .modal { 
            display: none; 
            position: fixed; 
            z-index: 100; 
            left: 0; 
            top: 0; 
            width: 100%; 
            height: 100%; 
            background-color: rgba(0,0,0,0.7); 
            /* Flexbox ensures the content is centered regardless of screen size */
            display: none; 
            align-items: center; 
            justify-content: center;
        }
        .modal-content { 
            background-color: var(--card); 
            margin: auto; 
            padding: 25px; 
            border: 1px solid var(--border); 
            width: 80%; 
            max-width: 500px; 
            border-radius: 10px; 
            color: var(--text); 
            position: relative;
            /* Scrollable logic */
            max-height: 80vh; 
            overflow-y: auto;
        }
        /* Footer */
        .app-footer { margin-top: 40px; padding-top: 20px; border-top: 1px solid var(--border); font-size: 11px; color: #90949c; line-height: 1.6; text-align: left; }
        .disclaimer-bold { font-weight: bold; color: var(--text); }

        /* Map UI */
        #mapOverlay { 
            display: none; position: fixed; top: 5%; left: 5%; width: 90%; height: 80%; 
            background: var(--card); z-index: 3000; border: 2px solid var(--primary); 
            border-radius: 12px; overflow: hidden; box-shadow: 0 20px 50px rgba(0,0,0,0.8);
        }
        #mapOverlay.maximized { width: 100vw; height: 100vh; top: 0; left: 0; border: none; border-radius: 0; }
        #map { width: 100%; height: 100%; background: #222; }

        .map-command-bar {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            width: auto; background: var(--glass); border: 1px solid var(--border); border-radius: 12px;
            padding: 10px 20px; display: flex; align-items: center; gap: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.6); backdrop-filter: blur(12px); z-index: 9999 !important;
        }
        .cmd-group { display: flex; align-items: center; gap: 8px; position: relative; }
        .cmd-divider { width: 1px; height: 24px; background: var(--border); margin: 0 4px; }
        .layer-switch { display: flex; background: rgba(0,0,0,0.4); border-radius: 6px; padding: 2px; border: 1px solid var(--border); }
        .layer-btn { background: transparent; border: none; color: #888; padding: 10px 16px; font-size: 13px; font-weight: 600; cursor: pointer; border-radius: 4px; transition: 0.2s; white-space: nowrap; height: 44px; display: flex; align-items: center; }
        .layer-btn.active { background: var(--primary); color: white; }
        .action-btn { background: var(--card); border: 1px solid var(--border); color: var(--text); padding: 10px 16px; font-size: 13px; border-radius: 6px; cursor: pointer; height: 44px; display: flex; align-items: center; gap: 6px; }
		.close { 
            position: sticky; 
            top: 0; 
            float: right; 
            color: var(--text); 
            font-size: 28px; 
            font-weight: bold; 
            cursor: pointer; 
            opacity: 0.6;
            z-index: 101; /* Ensure it stays above the list items */
            margin-top: -10px; /* Adjust alignment with header */
            margin-right: -5px;
        }
        .close-btn { background: var(--danger); border-color: var(--danger); color: white; }        
        #loader { position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.8); color: white; padding: 8px 15px; border-radius: 20px; font-size: 11px; display: none; align-items: center; gap: 10px; z-index: 10001; border: 1px solid var(--border); }
    </style>
</head>
<body data-theme="dark">

<div id="loader">FETCHING DATA...</div>

<div class="container">
    <div class="header-row">
        <div>
            <h2>Aviation obstacle .KML overlay generator</h2>
            <span class="version-subtitle" onclick="openVersionModal()">v2.6.1</span>
            <a href="https://github.com/cwmauze/aviation-obstacle-kml-tool" target="_blank" class="project-link">GitHub project home</a>
            <a href="mailto:cistern_fob3m@icloud.com" class="project-link">Contact / Feedback</a>
        </div>
        <button class="action-btn" onclick="toggleTheme()" id="themeBtn" style="font-size: 16px; padding: 6px 10px; height: auto;">☀️</button>
    </div>

    <div style="font-size: 13px; color: #90949c; margin-bottom: 25px; line-height: 1.5; max-width: 1400px; border-left: 2px solid var(--border); padding-left: 15px;">
        This tool generates custom KML obstacle overlays for use in ForeFlight, Google Earth, or any EFB/mapping platform that supports KML imports. The backend automatically synchronizes with the FAA's latest 56-Day Digital Obstacle File (DOF) and 28-Day NASR databases. NOTAM data for unlit obstacles is updated every 24 hours using the official FAA NMS-API. Simply set your centerpoint via FAA Identifier or Lat/Lon, define your search radius and altitude thresholds, customize your visual styling, and export your overlay.
    </div>

    <div class="session-status-card">
        <div style="font-weight: bold; color: var(--primary); text-transform: uppercase; font-size: 10px;">Database Status</div>
        <div class="status-line">
            <span>Airport/heliport data (NASR):</span>
            <div style="display:flex; align-items:center; gap:8px;">
                <span id="apt-status">Checking...</span>
                <div class="status-dot loading" id="apt-dot"></div>
            </div>
        </div><div class="status-line">
            <span>Obstacle data (DOF):</span>
            <div style="display:flex; align-items:center; gap:8px;">
                <span id="dof-status">Checking...</span>
                <div class="status-dot loading" id="dof-dot"></div>
            </div>
        </div>
        <div class="status-line">
            <span>NOTAM data:</span>
            <div style="display:flex; align-items:center; gap:8px;">
                <span id="notam-status">Checking...</span>
                <div class="status-dot loading" id="notam-dot"></div>
            </div>
        </div>
    </div>

    <div class="top-action-bar">
        <button class="btn-flat primary" onclick="document.getElementById('profileLoader').click()">
            <svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>
            Load Setup Template
        </button>
        <input type="file" id="profileLoader" accept=".json" style="display: none;" onchange="loadProfile(event)">
        
        <button class="btn-flat danger" onclick="resetToDefaults()">
            <svg viewBox="0 0 24 24"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
            Clear All Data
        </button>
    </div>

	<div class="section-card">
        <div class="section-title">
            <span>Search Area & Filtering</span>
            <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                <span id="liveCounter" style="background: var(--bg); color: var(--text); padding: 4px 10px; border-radius: 12px; font-weight: 600; font-size: 11px; border: 1px solid var(--border); text-transform: none; box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);">0 obstacles</span>
                <span id="notamLiveCounter" style="background: var(--bg); color: var(--text); padding: 4px 10px; border-radius: 12px; font-weight: 600; font-size: 11px; border: 1px solid var(--border); text-transform: none; box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);">0 active lighting outages</span>
            </div>
        </div>

        <div class="segmented-control">
            <input type="radio" name="centerMode" id="faaMode" value="faa" checked onchange="toggleCenterInput()">
            <label for="faaMode">FAA Identifier(s)</label>

            <input type="radio" name="centerMode" id="coordMode" value="coord" onchange="toggleCenterInput()">
            <label for="coordMode">Coordinates</label>

            <input type="radio" name="centerMode" id="routeMode" value="route" onchange="toggleCenterInput()">
            <label for="routeMode">Route Search</label>

            <input type="radio" name="centerMode" id="stateMode" value="state" onchange="toggleCenterInput()">
            <label for="stateMode">Entire US State(s)</label>
        </div>

        <div id="faaInputGroup">
            <input type="text" id="faaId" placeholder="e.g. KRDU, W40, NC91" style="text-transform: uppercase;" oninput="updateFacilityName()">
        </div>

        <div id="coordInputGroup" class="grid-2" style="display: none; margin-bottom: 0px;">
            <div>
                <label>Latitude</label>
                <input type="text" id="lat" placeholder="e.g. 36.0066 or 36 00.396 N" oninput="triggerCounterUpdate()">
            </div>
            <div>
                <label>Longitude</label>
                <input type="text" id="lon" placeholder="e.g. -78.9391 or 78 56.346 W" oninput="triggerCounterUpdate()">
            </div>
        </div>

        <div id="stateInputGroup" style="display: none; margin-bottom: 0px;">
            <input type="text" id="stateIds" placeholder="e.g. NC, VA, SC" style="text-transform: uppercase;" oninput="triggerCounterUpdate()">
        </div>

        <div id="sharedHelperText" style="font-size: 11px; color: #90949c; margin-top: 6px; margin-left: 4px;">Enter a single ID (e.g. KABQ) or a comma-separated list for a multi-point search.</div>
        
        <div id="facilityName"></div>

        <div id="radiusWrap" class="inline-control" style="margin-top: 15px; margin-bottom: 0px; border-color: var(--primary);">
            <label style="margin-bottom: 0; font-weight: bold; color: var(--primary);">Search radius</label>
            <input type="range" id="searchNMSlider" min="5" max="500" step="5" value="150" oninput="document.getElementById('radiusNM').value = this.value; triggerCounterUpdate();">
            <div style="display: flex; align-items: center; gap: 6px;">
                <input type="number" id="radiusNM" value="150" oninput="document.getElementById('searchNMSlider').value = this.value; triggerCounterUpdate();" style="width: 70px; height: 36px; padding: 4px 8px; margin: 0; background: var(--card); border-radius: 6px; font-size: 15px; font-weight: bold; text-align: center;">
                <span style="font-size: 12px; font-weight: bold; color: var(--text); opacity: 0.8;">NM</span>
            </div>
        </div>

        <div style="height: 1px; background: var(--border); margin: 20px 0 15px 0;"></div>

        <div class="grid-2">
            <div class="col-divider">
                <div class="checkbox-group" style="margin-bottom: 12px;">
                    <input type="checkbox" id="stdInclude" checked onchange="triggerCounterUpdate(); toggleLayerOptions()">
                    <label for="stdInclude" style="font-weight: bold; color: var(--primary); font-size: 13px; letter-spacing: 0.3px;">Include standard obstacles (DOF)</label>
                </div>
                <div id="stdOptionsGroup">
                    <label>Minimum obstacle height (ft AGL)</label>
                    <input type="number" id="minAGL" value="1000" oninput="checkAGLWarning()">
                    <div id="aglWarning" style="display: none; color: var(--danger); font-size: 10px; margin-top: 5px; font-weight: bold;">FAA database excludes obstacles under 200 AGL.</div>
                </div>
            </div>
            <div>
                <div class="checkbox-group" style="margin-bottom: 12px;">
                    <input type="checkbox" id="notamInclude" checked style="accent-color: var(--dispatch);" onchange="triggerCounterUpdate(); toggleLayerOptions()">
                    <label for="notamInclude" style="font-weight: bold; color: var(--dispatch); font-size: 13px; letter-spacing: 0.3px;">Include active light outage NOTAMs</label>
                </div>
                <div id="notamOptionsGroup">
                    <label>Minimum height (ft AGL)</label>
                    <input type="number" id="notamMinAGL" value="200" oninput="triggerCounterUpdate()">
                </div>
            </div>
        </div>
    </div>

    <div class="section-card" id="boundaryWrap">
        <div class="section-title">Search Boundary Styling</div>
        <div class="checkbox-group" style="margin-bottom: 12px;">
            <input type="checkbox" id="enableBoundary" checked onchange="toggleBoundaryOpacitySlider()">
            <label for="enableBoundary" style="font-weight: bold; color: var(--primary); font-size: 13px; letter-spacing: 0.3px;">Include search boundaries in KML overlay</label>
        </div>
        
        <div class="grid-2" id="boundarySettingsGrid">
            <div class="inline-control">
                <label>Line color</label>
                <input type="color" id="boundaryColor" value="#ff0000">
            </div>
            <div class="inline-control">
                <label>Line thickness (px)</label>
                <input type="number" id="boundaryWidth" value="2" min="1" max="10" style="width: 70px; height: 36px; padding: 4px 8px; margin: 0; background: var(--card); border-radius: 6px; font-size: 15px; font-weight: bold; text-align: center;">
            </div>
            <div class="inline-control" id="boundaryOpacityGroup" style="grid-column: span 2;">
                <label style="display:flex; align-items:center; width:100%; gap: 8px;">
                    <span style="font-size: 13px; font-weight: bold; min-width: 60px;">Opacity</span>
                    <input type="range" id="boundaryLineOpacity" min="0" max="100" step="5" value="100" oninput="updateBoundaryOpacityLabel()" style="height: 36px; flex: 1;">
                    <span id="boundaryOpacityValue" style="color:var(--primary); font-size: 13px; font-weight: bold; min-width: 40px; text-align: right;">100%</span>
                </label>
            </div>
        </div>
    </div>

    <div class="section-card" id="stdStylingCard">
        <div class="section-title">Standard Obstacle Styling</div>
        
        <div class="inline-control" id="stdMasterWrap" style="margin-bottom: 15px; border-color: var(--danger);">
            <label id="stdMasterLabel" style="font-weight: bold; color: var(--danger); white-space: nowrap;">Ring radius</label>
            <input type="range" id="ringNMSlider" min="0.1" max="10.0" step="0.1" value="2.0" oninput="document.getElementById('ringNM').value = this.value">
            <div style="display: flex; align-items: center; gap: 6px;">
                <input type="number" id="ringNM" value="2.0" step="0.1" min="0.1" max="10.0" oninput="document.getElementById('ringNMSlider').value = this.value" style="width: 70px; height: 36px; padding: 4px 8px; margin: 0; background: var(--card); border-radius: 6px; font-size: 15px; font-weight: bold; text-align: center;">
                <span style="font-size: 12px; font-weight: bold; color: var(--text); opacity: 0.8;">NM</span>
            </div>
        </div>

        <div class="grid-2">
            <div>
                <div style="display: flex; align-items: center; height: 26px; margin-bottom: 8px;">
                    <div style="font-weight: bold; color: var(--text); font-size: 12px; margin-left: 2px; opacity: 0.8;">Obstacle ring outline</div>
                </div>
                
                <div class="inline-control">
                    <label>Line color</label>
                    <input type="color" id="outlineColor" value="#ff0000" oninput="updateStdRingColor()">
                </div>
                <div class="inline-control">
                    <label>Line thickness</label>
                    <div style="display: flex; align-items: center; gap: 6px;">
                        <input type="number" id="ringWidth" value="2" min="1" max="10" style="width: 70px; height: 36px; padding: 4px 8px; margin: 0; background: var(--card); border-radius: 6px; font-size: 15px; font-weight: bold; text-align: center;">
                        <span style="font-size: 12px; font-weight: bold; color: var(--text); opacity: 0.8;">px</span>
                    </div>
                </div>
                <div class="inline-control">
                    <label style="display:flex; align-items:center; width:100%; gap: 8px;">
                        <span style="font-size: 13px; font-weight: bold; min-width: 60px;">Opacity</span>
                        <input type="range" id="outlineOpacity" min="0" max="100" step="5" value="100" oninput="updateOutlineOpacityLabel()" style="height: 36px; flex: 1;">
                        <span id="outlineOpacityValue" style="color:var(--primary); font-size: 13px; font-weight: bold; min-width: 40px; text-align: right;">100%</span>
                    </label>
                </div>
            </div>
            
            <div>
                <div style="display: flex; align-items: center; height: 26px; margin-bottom: 8px;">
                    <div style="font-weight: bold; color: var(--text); font-size: 12px; margin-left: 2px; opacity: 0.8;">Obstacle ring fill</div>
                </div>

                <div class="checkbox-group" style="margin-bottom: 12px;">
                    <input type="checkbox" id="enableFill" checked onchange="toggleOpacitySlider()">
                    <label for="enableFill">Enable shading for obstacle rings</label>
                </div>
                
                <div class="inline-control" id="opacityGroup">
                    <label style="display:flex; align-items:center; width:100%; gap: 8px;">
                        <span style="font-size: 13px; font-weight: bold; min-width: 60px;">Opacity</span>
                        <input type="range" id="fillOpacity" min="0" max="100" step="5" value="50" oninput="updateOpacityLabel()" style="height: 36px; flex: 1;">
                        <span id="opacityValue" style="color:var(--primary); font-size: 13px; font-weight: bold; min-width: 40px; text-align: right;">50%</span>
                    </label>
                    <input type="color" id="fillColor" value="#ff0000">
                </div>
            </div>

        </div>
    </div>

    <div class="section-card" id="notamStylingCard">
        <div class="section-title">Unlit Obstacle Styling</div>
        
        <div class="inline-control" id="notamMasterWrap" style="margin-bottom: 15px; border-color: var(--dispatch);">
            <label id="notamMasterLabel" style="font-weight: bold; color: var(--dispatch); white-space: nowrap;">Ring radius</label>
            <input type="range" id="notamRingNMSlider" min="0.1" max="10.0" step="0.1" value="3.0" oninput="document.getElementById('notamRingNM').value = this.value">
            <div style="display: flex; align-items: center; gap: 6px;">
                <input type="number" id="notamRingNM" value="3.0" step="0.1" min="0.1" max="10.0" oninput="document.getElementById('notamRingNMSlider').value = this.value" style="width: 70px; height: 36px; padding: 4px 8px; margin: 0; background: var(--card); border-radius: 6px; font-size: 15px; font-weight: bold; text-align: center;">
                <span style="font-size: 12px; font-weight: bold; color: var(--text); opacity: 0.8;">NM</span>
            </div>
        </div>

        <div class="grid-2">
            <div>
                <div style="display: flex; align-items: center; height: 26px; margin-bottom: 8px;">
                    <div style="font-weight: bold; color: var(--text); font-size: 12px; margin-left: 2px; opacity: 0.8;">Hazard ring outline</div>
                </div>
                
                <div class="inline-control">
                    <label>Line color</label>
                    <input type="color" id="notamOutlineColor" value="#ff9900" oninput="updateNotamRingColor()">
                </div>
                <div class="inline-control">
                    <label>Line thickness</label>
                    <div style="display: flex; align-items: center; gap: 6px;">
                        <input type="number" id="notamRingWidth" value="3" min="1" max="10" style="width: 70px; height: 36px; padding: 4px 8px; margin: 0; background: var(--card); border-radius: 6px; font-size: 15px; font-weight: bold; text-align: center;">
                        <span style="font-size: 12px; font-weight: bold; color: var(--text); opacity: 0.8;">px</span>
                    </div>
                </div>
                <div class="inline-control">
                    <label style="display:flex; align-items:center; width:100%; gap: 8px;">
                        <span style="font-size: 13px; font-weight: bold; min-width: 60px;">Opacity</span>
                        <input type="range" id="notamOutlineOpacity" min="0" max="100" step="5" value="100" oninput="updateNotamOutlineOpacityLabel()" style="height: 36px; flex: 1;">
                        <span id="notamOutlineOpacityValue" style="color:var(--primary); font-size: 13px; font-weight: bold; min-width: 40px; text-align: right;">100%</span>
                    </label>
                </div>
            </div>
            
            <div>
                <div style="display: flex; align-items: center; height: 26px; margin-bottom: 8px;">
                    <div style="font-weight: bold; color: var(--text); font-size: 12px; margin-left: 2px; opacity: 0.8;">Hazard ring fill</div>
                </div>

                <div class="checkbox-group" style="margin-bottom: 12px;">
                    <input type="checkbox" id="notamEnableFill" checked onchange="toggleNotamOpacitySlider()">
                    <label for="notamEnableFill">Enable shading for unlit obstacle rings</label>
                </div>
                
                <div class="inline-control" id="notamOpacityGroup">
                    <label style="display:flex; align-items:center; width:100%; gap: 8px;">
                        <span style="font-size: 13px; font-weight: bold; min-width: 60px;">Opacity</span>
                        <input type="range" id="notamFillOpacity" min="0" max="100" step="5" value="60" oninput="updateNotamOpacityLabel()" style="height: 36px; flex: 1;">
                        <span id="notamOpacityValue" style="color:var(--primary); font-size: 13px; font-weight: bold; min-width: 40px; text-align: right;">60%</span>
                    </label>
                    <input type="color" id="notamFillColor" value="#ff9900">
                </div>
            </div>
        </div>
    </div>

    <div class="section-card" style="margin-bottom: 0;">
        <div class="section-title">Export Settings</div>
        <div class="grid-2">
            <div>
                <label>Custom Route/File Name (Optional)</label>
                <input type="text" id="customFileName" placeholder="e.g. Night Route Alpha">
            </div>
            <div>
                <label>Filename Format</label>
                <select id="fileNameFormat" style="cursor: pointer;">
                    <option value="verbose">Verbose (Name-[Height]AGL-[Radius]-Date)</option>
                    <option value="standard">Standard (Name_[Height]AGL)</option>
                    <option value="short">Short (Name Only)</option>
                </select>
            </div>
        </div>
    </div>

    <div class="btn-group">
        <button class="btn-stacked btn-preview" onclick="showMapPreview()" style="flex: 1;">
            <svg viewBox="0 0 24 24"><polygon points="1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6"></polygon><line x1="8" y1="2" x2="8" y2="18"></line><line x1="16" y1="6" x2="16" y2="22"></line></svg>
            <div class="btn-title">Preview on map</div>
            <div class="btn-sub">STREET / SAT / VFR</div>
        </button>

        <button class="btn-stacked btn-slate" onclick="saveProfile()" style="flex: 1;">
            <svg viewBox="0 0 24 24"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg>
            <div class="btn-title">Save setup as template</div>
            <div class="btn-sub">JSON TEMPLATE</div>
        </button>

        <button class="btn-stacked btn-download" onclick="generateKML()" style="flex: 1;">
            <svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
            <div class="btn-title">Download .KML</div>
            <div class="btn-sub">FOREFLIGHT/GOOGLE EARTH</div>
        </button>
    </div>

    <footer class="app-footer">
        <span class="disclaimer-bold">DISCLAIMER:</span> This tool is for utility purposes only and is not a substitute for aggressive scanning or an up-to-date TAWS. While the database is meticulously parsed, cumulo-granite and steel towers+guy wires remain strictly unforgiving. Generating a colorful KML file does not grant you invincibility. Cross-reference official charts and don't hit stuff.
    </footer>
</div>

<div id="versionModal" class="modal">
  <div class="modal-content">
    <span class="close" onclick="closeVersionModal()">&times;</span>
    <h3 style="margin-top: 0; color: var(--primary);">Version History</h3>
    <ul style="padding-left: 20px; line-height: 1.6; font-size: 13px;">
    	<li><strong>v2.6.1:</strong> Tweaked UI, added more sliders.</li>
    	<li><strong>v2.5:</strong> Implemented save/load profile functionality.</li>
    	<li><strong>v2.5:</strong> Major restyle - reorganized options into search area.</li>
    	<li><strong>v2.4.2:</strong> Added opacity options for obstacle/NOTAM rings.</li>
    	<li><strong>v2.4.1:</strong> UI tweak, added contact email.</li>
    	<li><strong>v2.4:</strong> Fixed NOTAM update frequency in update_database.</li>
    	<li><strong>v2.3:</strong> Added slider style selectors and tweaked UI for readabilty.</li>
    	<li><strong>v2.2.1:</strong> Fixed export issue with new UI / filename options.</li>
    	<li><strong>v2.2:</strong> Added standard obstacle toggle and custom filename options.</li>
    	<li><strong>v2.1.1:</strong> Minor UI update.</li>
    	<li><strong>v2.1.0:</strong> Integrated official FAA NMS-API. Up-scoped NOTAM logic to process nationwide datasets with geospatial cross-referencing for state-mode bounding. Removed experimental tags.</li>
        <li><strong>v2.0.4 (beta):</strong> Updated NOTAM Javascript regex parsing logic to correctly handle decimal formats and unblock the altitude filter.</li>
        <li><strong>v2.0.3 (beta):</strong> Complete AGL Parsing overhaul to catch messy FAA NOTAM formats. Implemented independent live counter for NOTAM outages in Section 4.</li>
        <li><strong>v2.0.2 (beta):</strong> Added dedicated altitude filter for unlit NOTAM obstacles.</li>
        <li><strong>v2.0.1 (beta):</strong> Added Experimental Section 4 for scraping and rendering active FAA NOTAM light outages.</li>
        <li><strong>v1.9.3:</strong> Added Real-Time Obstacle Counter, background RAM pre-loading, US State/Territory code validation guardrails, and unified ring radius styling options.</li>
        <li><strong>v1.9:</strong> Major Update. Added advanced Multi-Radii search support and entire State/Territory filtering mode for comprehensive route planning. Map preview logic updated to dynamically bound to generated coordinates.</li>
        <li><strong>v1.8.3:</strong> Added strict data validation guardrails to prevent mathematical errors and browser crashes from invalid inputs.</li>
        <li><strong>v1.8.2:</strong> Added dynamic safety warning for obstacle heights below 200 ft AGL and updated project repository URL.</li>
        <li><strong>v1.8.1:</strong> Added expanded introductory text, GitHub repository link, UI alignment fixes, light mode contrast adjustments, and snarky footer disclaimer.</li>
        <li><strong>v1.8:</strong> Fixed layout grouping in Overlay Options. Added line thickness controls for boundary and rings. Default colors unified to red.</li>
        <li><strong>v1.7:</strong> UI Optimization. Migrated to responsive 2-column card grid and compact inline color pickers to eliminate dead space.</li>
        <li><strong>v1.6:</strong> Title update, dynamic filename and layer naming, and NASR effective date display.</li>
        <li><strong>v1.5:</strong> Updated UI feedback for centerpoint facility validation.</li>
        <li><strong>v1.4:</strong> Smart K-identifier lookup, facility name auto-population, and simplified direct map layer controls.</li>
        <li><strong>v1.3:</strong> Integrated NASR FAA Airport database lookup and live DB validity status card.</li>
        <li><strong>v1.2:</strong> UI upgrade to Genesys styling. Added full visual Map Preview capability with Leaflet integration and FAA sectional charts.</li>
        <li><strong>v1.1:</strong> Added search boundary ring, customizable boundary colors, dark mode UI fixes, and single-file consolidation.</li>
        <li><strong>v1.0:</strong> Initial release. Added custom coordinate selection, height filtering, nautical mile conversion, and obstacle opacity settings.</li>
    </ul>
  </div>
</div>

<div id="mapOverlay">
    <div class="map-command-bar">
        <div class="cmd-group">
            <div class="layer-switch">
                <button class="layer-btn active" id="b-street" onclick="setBaseView('street')">Map Light</button>
                <button class="layer-btn" id="b-dark" onclick="setBaseView('dark')">Map Dark</button>
                <button class="layer-btn" id="b-sat" onclick="setBaseView('sat')">Satellite</button>
                <button class="layer-btn" id="b-vfr" onclick="setBaseView('vfr')">VFR Sectional</button>
            </div>
        </div>
        
        <div class="cmd-divider"></div>
        
        <div class="cmd-group" style="margin-left:auto;">
            <button class="action-btn" onclick="toggleMaximize()">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 3h6v6M9 21H3v-6M21 3l-7 7M3 21l7-7"></path></svg>
            </button>
            <button class="action-btn close-btn" onclick="hideMap()">Close</button>
        </div>
    </div>
    <div id="map"></div>
</div> 

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
// --- GLOBAL DB INITIALIZATION ---
let globalAirports = {};
let globalObstacles = null; // Memory Cache 
let globalNotams = []; // NOTAM Cache
let dbVersion = new Date().getTime(); // Cache Buster

const validStates = ['AL', 'AK', 'AZ', 'AR', 'CA', 'CO', 'CT', 'DE', 'FL', 'GA', 'HI', 'ID', 'IL', 'IN', 'IA', 'KS', 'KY', 'LA', 'ME', 'MD', 'MA', 'MI', 'MN', 'MS', 'MO', 'MT', 'NE', 'NV', 'NH', 'NJ', 'NM', 'NY', 'NC', 'ND', 'OH', 'OK', 'OR', 'PA', 'RI', 'SC', 'SD', 'TN', 'TX', 'UT', 'VT', 'VA', 'WA', 'WV', 'WI', 'WY', 'DC', 'PR', 'VI', 'GU', 'AS', 'MP'];

window.onload = async () => {
    try {
        const metaRes = await fetch('metadata.json?nocache=' + new Date().getTime());
        const meta = await metaRes.json();
        
        dbVersion = encodeURIComponent((meta.dof_date || '') + (meta.obs_count || ''));
        
        const obsCount = meta.obs_count || 0;
        document.getElementById('dof-status').innerText = `Verified (Eff. ${meta.dof_date} | ${obsCount} obstacles)`;
        document.getElementById('dof-dot').className = obsCount > 0 ? 'status-dot ready' : 'status-dot error';
        
        const aptRes = await fetch(`airports.json?v=${dbVersion}`);
        globalAirports = await aptRes.json();
        
        const aptCount = meta.apt_count || Object.keys(globalAirports).length;
        const aptDate = meta.apt_date || meta.dof_date || "Unknown";
        document.getElementById('apt-status').innerText = `Verified (Eff. ${aptDate} | ${aptCount} airports/heliports found)`;
        document.getElementById('apt-dot').className = aptCount > 0 ? 'status-dot ready' : 'status-dot error';
        
        getObstacles().then(() => triggerCounterUpdate());

		try {
            // NOTAMs change constantly, so we bypass the browser cache using a live timestamp
            const notamRes = await fetch(`notams.json?nocache=${new Date().getTime()}`);
            globalNotams = await notamRes.json();
            const notamDate = meta.notam_date || "Unknown";
            document.getElementById('notam-status').innerText = `Verified (Updated: ${notamDate} | ${globalNotams.length} active outages)`;
            document.getElementById('notam-dot').className = globalNotams.length > 0 ? 'status-dot ready' : 'status-dot error';
        } catch(e) {
            console.warn("NOTAM fetch failed or file missing.");
            document.getElementById('notam-status').innerText = "Offline / No Data";
            document.getElementById('notam-dot').className = 'status-dot error';
        }

    } catch(e) {
        console.error("Database fetch failed: ", e);
        document.getElementById('dof-status').innerText = "Offline (Local mode only)";
        document.getElementById('dof-dot').className = 'status-dot error';
        document.getElementById('apt-status').innerText = "Offline";
        document.getElementById('apt-dot').className = 'status-dot error';
        document.getElementById('coordMode').click(); 
    }
};

// --- EFFICIENT MEMORY LOADER ---
async function getObstacles() {
    if (!globalObstacles) {
        const response = await fetch(`obstacles.json?v=${dbVersion}`);
        globalObstacles = await response.json();
    }
    return globalObstacles;
}

// --- NOTAM AGL PARSER (SMART OVERRIDE) ---
function parseNotamAGL(text, fallback) {
    if (!text) return (fallback === "1" || fallback === "Unknown") ? "Unknown" : fallback;
    
    // Pattern 1: Captures decimals as well! (e.g., 250 AGL, 1017.4FT AGL, 250 FT AGL)
    const aglMatch = text.match(/(\d+(?:\.\d+)?)\s*(?:FT)?\s*AGL/i);
    if (aglMatch) return aglMatch[1];
    
    // Pattern 2: Fallback for MSL enclosures like 1049 MSL ( 250 )
    const backupMatch = text.match(/MSL\s*\(\s*(\d+(?:\.\d+)?)\s*(?:FT)?\s*\)/i);
    if (backupMatch) return backupMatch[1];
    
    if (fallback && fallback !== "1" && fallback !== "Unknown") return fallback;
    return "Unknown";
}

// --- REAL-TIME COUNTER (DEBOUNCED) ---
let counterTimeout;
function triggerCounterUpdate() {
    clearTimeout(counterTimeout);
    counterTimeout = setTimeout(runLiveCounter, 500);
}

async function runLiveCounter() {
    if (!globalObstacles) return;
    
    // UI Loading States
    const counterEl = document.getElementById('liveCounter');
    counterEl.innerText = "Calculating...";
    counterEl.style.color = "var(--dispatch)";

    const notamCounterEl = document.getElementById('notamLiveCounter');
    if (notamCounterEl) {
        notamCounterEl.innerText = "Calculating...";
        notamCounterEl.style.color = "var(--dispatch)";
    }

    const mode = document.querySelector('input[name="centerMode"]:checked').value;
    const minAGL = parseInt(document.getElementById('minAGL').value);
    const searchRadiusNM = parseFloat(document.getElementById('radiusNM').value);
    const centers = getCenterCoords();
    
    // Define target states early for both loops
    let targetStates = [];
    if (mode === 'state') {
        const rawStates = document.getElementById('stateIds').value;
        targetStates = rawStates.split(',').map(s => s.trim().toUpperCase()).filter(s => s.length === 2);
    }
    
    let count = 0;
    let notamCount = 0;

    // 1. Process Standard Obstacles
    const incStd = document.getElementById('stdInclude').checked;
    
    if (incStd && !isNaN(minAGL)) {
        if (mode === 'state') {
            if (targetStates.length > 0) {
                for (let i = 0; i < globalObstacles.length; i++) {
                    const obs = globalObstacles[i];
                    if (obs.agl > minAGL && targetStates.includes(obs.state)) count++;
                }
            }
        } else if (centers && centers.length > 0 && !isNaN(searchRadiusNM)) {
            for (let i = 0; i < globalObstacles.length; i++) {
                const obs = globalObstacles[i];
                if (obs.agl > minAGL) {
                    let inArea = false;
                    if (mode === 'route' && centers.length > 1) {
                        for (let j = 0; j < centers.length - 1; j++) {
                            if (pointToSegmentDistanceNM(obs.lat, obs.lon, centers[j].lat, centers[j].lon, centers[j+1].lat, centers[j+1].lon) <= searchRadiusNM) {
                                inArea = true; break;
                            }
                        }
                    } else {
                        for (let j = 0; j < centers.length; j++) {
                            if (haversineNM(centers[j].lat, centers[j].lon, obs.lat, obs.lon) <= searchRadiusNM) {
                                inArea = true; break;
                            }
                        }
                    }
                    if (inArea) count++;
                }	
            }
        }
    }

    // 2. Process NOTAMs (with Geospatial State Hack)
    const incNotam = document.getElementById('notamInclude').checked;
    const notamMinAGL = parseInt(document.getElementById('notamMinAGL').value) || 0;

    // OPTIMIZATION: Pre-filter state obstacles to prevent a 2.8 Billion iteration loop
    let stateObstacles = [];
    if (mode === 'state' && targetStates.length > 0) {
        stateObstacles = globalObstacles.filter(o => targetStates.includes(o.state));
    }

    if (incNotam && globalNotams) {
        for (let i = 0; i < globalNotams.length; i++) {
            const notam = globalNotams[i];
            let keep = false;

            if (mode === 'state') {
                if (targetStates.length > 0) {
                    for (let k = 0; k < stateObstacles.length; k++) {
                        // Quick bounding box check (~1.2 NM) before expensive trig math
                        if (Math.abs(stateObstacles[k].lat - notam.lat) < 0.02 && Math.abs(stateObstacles[k].lon - notam.lon) < 0.02) {
                            if (haversineNM(stateObstacles[k].lat, stateObstacles[k].lon, notam.lat, notam.lon) <= 1.0) {
                                keep = true;
                                break;
                            }
                        }
                    }
                }
            } else if (centers && !isNaN(searchRadiusNM)) {
                if (mode === 'route' && centers.length > 1) {
                    for (let j = 0; j < centers.length - 1; j++) {
                        if (pointToSegmentDistanceNM(notam.lat, notam.lon, centers[j].lat, centers[j].lon, centers[j+1].lat, centers[j+1].lon) <= searchRadiusNM) {
                            keep = true; break;
                        }
                    }
                } else {
                    for (let j = 0; j < centers.length; j++) {
                        if (haversineNM(centers[j].lat, centers[j].lon, notam.lat, notam.lon) <= searchRadiusNM) {
                            keep = true; break;
                        }
                    }
                }
            }

            if (keep) {
                let finalAgl = parseNotamAGL(notam.text, notam.agl);
                let aglNum = parseFloat(finalAgl);
                if (!isNaN(aglNum) && aglNum < notamMinAGL) {
                    keep = false;
                }
            }

            if (keep) notamCount++;
        }
    }

// Update UI Counters
    if (!incStd) {
        counterEl.innerText = "Layer Disabled";
        counterEl.style.color = "var(--text)";
    } else {
        counterEl.innerText = `${count} Obstacle${count !== 1 ? 's' : ''}`;
        counterEl.style.color = count > 0 ? "var(--success)" : "var(--text)";
    }

    if (notamCounterEl) {
            if (!incNotam) {
                notamCounterEl.innerText = "Layer Disabled";
                notamCounterEl.style.color = "var(--text)";
            } else {
                notamCounterEl.innerText = `${notamCount} Active Outage${notamCount !== 1 ? 's' : ''}`;
                notamCounterEl.style.color = notamCount > 0 ? "var(--dispatch)" : "var(--text)";
            }
        }

        // Live-update the Filename Format dropdown options
        const formatDropdown = document.getElementById('fileNameFormat');
        if (formatDropdown) {
            const aglStr = isNaN(minAGL) ? "[Height]" : minAGL;
            const radStr = mode === 'state' ? "STATE" : (isNaN(searchRadiusNM) ? "[Radius]" : searchRadiusNM + "NM");
            formatDropdown.options[0].text = `Verbose (Name-${aglStr}AGL-${radStr}-Date)`;
            formatDropdown.options[1].text = `Standard (Name_${aglStr}AGL)`;
        }
    }

// --- CORE UI CONTROLS ---
function toggleTheme() {
    const body = document.body;
    const btn = document.getElementById('themeBtn');
    const isNowLight = body.getAttribute('data-theme') !== 'light';
    body.setAttribute('data-theme', isNowLight ? 'light' : 'dark');
    btn.innerText = isNowLight ? '🌙' : '☀️';
}

function toggleCenterInput(isProfileLoad = false) {
    const mode = document.querySelector('input[name="centerMode"]:checked').value;
    
    // Show the identifier input box for both standard points and route search
    document.getElementById('faaInputGroup').style.display = (mode === 'faa' || mode === 'route') ? 'block' : 'none';
    document.getElementById('coordInputGroup').style.display = mode === 'coord' ? 'grid' : 'none';
    document.getElementById('stateInputGroup').style.display = mode === 'state' ? 'block' : 'none';
    
    // Use 'flex' instead of 'block' to maintain the inline-control styling
    document.getElementById('radiusWrap').style.display = mode === 'state' ? 'none' : 'flex';
    document.getElementById('boundaryWrap').style.display = mode === 'state' ? 'none' : 'block';

    // Dynamically update the radius label, helper text, and default values
    const radiusLabel = document.querySelector('#radiusWrap label');
    const radiusInput = document.getElementById('radiusNM');
    const sharedHelper = document.getElementById('sharedHelperText');

    const searchNMSlider = document.getElementById('searchNMSlider');
    
    if (mode === 'route') {
        if (radiusLabel) radiusLabel.innerText = 'Corridor half-width (NM)';
        if (sharedHelper) sharedHelper.innerText = 'Enter at least two comma-separated IDs to define your route (e.g. KABQ, KSAF, KDEN).';
        if (searchNMSlider) { searchNMSlider.max = "10"; searchNMSlider.min = "1"; searchNMSlider.step = "1"; }
        if (radiusInput) { radiusInput.max = "10"; radiusInput.min = "1"; }
        if (!isProfileLoad && radiusInput && radiusInput.value === "150") { radiusInput.value = "4"; if(searchNMSlider) searchNMSlider.value = "4"; } // Smart default swap bypassed on load
    } else if (mode === 'coord') {
        if (radiusLabel) radiusLabel.innerText = 'Search radius (NM)';
        if (sharedHelper) sharedHelper.innerText = 'Accepts decimal, DDM, or DMS formats. Use negative numbers or S/W for South/West.';
        if (searchNMSlider) { searchNMSlider.max = "500"; searchNMSlider.min = "5"; searchNMSlider.step = "5"; }
        if (radiusInput) { radiusInput.max = "500"; radiusInput.min = "5"; }
        if (!isProfileLoad && radiusInput && radiusInput.value === "4") { radiusInput.value = "150"; if(searchNMSlider) searchNMSlider.value = "150"; }
    } else if (mode === 'state') {
        if (sharedHelper) sharedHelper.innerText = 'Enter comma-separated 2-letter state codes.';
    } else { // 'faa' mode
        if (radiusLabel) radiusLabel.innerText = 'Search radius (NM)';
        if (sharedHelper) sharedHelper.innerText = 'Enter a single ID (e.g. KABQ) or a comma-separated list for a multi-point search.';
        if (searchNMSlider) { searchNMSlider.max = "500"; searchNMSlider.min = "5"; searchNMSlider.step = "5"; }
        if (radiusInput) { radiusInput.max = "500"; radiusInput.min = "5"; }
        if (!isProfileLoad && radiusInput && radiusInput.value === "4") { radiusInput.value = "150"; if(searchNMSlider) searchNMSlider.value = "150"; } // Smart default swap bypassed on load
    }

    const facName = document.getElementById('facilityName');
    if (mode === 'faa' || mode === 'route') {
        if (facName) facName.style.display = 'block';
        updateFacilityName();
    } else {
        if (facName) facName.style.display = 'none';
    }
    
    triggerCounterUpdate();
}

function openVersionModal() { 
    const modal = document.getElementById('versionModal');
    modal.style.display = 'flex'; 
}
function closeVersionModal() { document.getElementById('versionModal').style.display = 'none'; }
window.onclick = function(event) { if (event.target === document.getElementById('versionModal')) closeVersionModal(); }

function updateOpacityLabel() { document.getElementById('opacityValue').textContent = document.getElementById('fillOpacity').value + '%'; }
function toggleOpacitySlider() { document.getElementById('opacityGroup').style.display = document.getElementById('enableFill').checked ? 'flex' : 'none'; }
function updateNotamOpacityLabel() { document.getElementById('notamOpacityValue').textContent = document.getElementById('notamFillOpacity').value + '%'; }
function toggleNotamOpacitySlider() { document.getElementById('notamOpacityGroup').style.display = document.getElementById('notamEnableFill').checked ? 'flex' : 'none'; }

// New Outline/Boundary Opacity Handlers
function updateOutlineOpacityLabel() { document.getElementById('outlineOpacityValue').textContent = document.getElementById('outlineOpacity').value + '%'; }
function updateNotamOutlineOpacityLabel() { document.getElementById('notamOutlineOpacityValue').textContent = document.getElementById('notamOutlineOpacity').value + '%'; }
function updateBoundaryOpacityLabel() { document.getElementById('boundaryOpacityValue').textContent = document.getElementById('boundaryLineOpacity').value + '%'; }
function toggleBoundaryOpacitySlider() { document.getElementById('boundarySettingsGrid').style.display = document.getElementById('enableBoundary').checked ? 'grid' : 'none'; }

function toggleLayerOptions() {
    const stdChecked = document.getElementById('stdInclude').checked;
    const notamChecked = document.getElementById('notamInclude').checked;
    
    const stdGroup = document.getElementById('stdOptionsGroup');
    const stdCard = document.getElementById('stdStylingCard');
    if (stdGroup) stdGroup.style.display = stdChecked ? 'block' : 'none';
    if (stdCard) stdCard.style.display = stdChecked ? 'block' : 'none';
    
    const notamGroup = document.getElementById('notamOptionsGroup');
    const notamCard = document.getElementById('notamStylingCard');
    if (notamGroup) notamGroup.style.display = notamChecked ? 'block' : 'none';
    if (notamCard) notamCard.style.display = notamChecked ? 'block' : 'none';
}

// Dynamic Ring Radius UI Highlight Handlers
function updateStdRingColor() {
    const color = document.getElementById('outlineColor').value;
    document.getElementById('stdMasterWrap').style.borderColor = color;
    document.getElementById('stdMasterLabel').style.color = color;
}
function updateNotamRingColor() {
    const color = document.getElementById('notamOutlineColor').value;
    document.getElementById('notamMasterWrap').style.borderColor = color;
    document.getElementById('notamMasterLabel').style.color = color;
}

function checkAGLWarning() {
    const agl = parseInt(document.getElementById('minAGL').value) || 0;
    document.getElementById('aglWarning').style.display = agl < 200 ? 'block' : 'none';
    triggerCounterUpdate();
}

// --- INPUT VALIDATION ---
function validateInputs() {
    const mode = document.querySelector('input[name="centerMode"]:checked').value;

    if (mode !== 'state') {
        const radiusNM = parseFloat(document.getElementById('radiusNM').value);
        const maxRadius = mode === 'route' ? 10 : 500;
        const minRadius = mode === 'route' ? 1 : 5;
        if (isNaN(radiusNM) || radiusNM < minRadius || radiusNM > maxRadius) {
            alert(`Search radius/width must be between ${minRadius} and ${maxRadius} NM.`);
            return false;
        }
    }
    
    if (mode === 'route') {
        const apts = getResolvedAirports(document.getElementById('faaId').value);
        if (apts.length < 2) {
            alert("Route search requires at least two valid identifiers (e.g., KABQ, KSAF).");
            return false;
        }
    }

    if (mode === 'coord') {
        const lat = parseFloat(document.getElementById('lat').value);
        const lon = parseFloat(document.getElementById('lon').value);
        if (isNaN(lat) || lat < -90.0 || lat > 90.0) {
            alert("Latitude must be between -90.0 and 90.0 degrees.");
            return false;
        }
        if (isNaN(lon) || lon < -180.0 || lon > 180.0) {
            alert("Longitude must be between -180.0 and 180.0 degrees.");
            return false;
        }
    }
    
    if (mode === 'state') {
        const states = document.getElementById('stateIds').value.split(',').map(s=>s.trim().toUpperCase()).filter(s=>s.length===2);
        if (states.length === 0) {
            alert("Please enter at least one valid 2-letter state code (e.g. NC, VA).");
            return false;
        }
        
        const invalidStates = states.filter(s => !validStates.includes(s));
        if (invalidStates.length > 0) {
            alert(`Invalid state/territory code(s) detected: ${invalidStates.join(', ')}. Please use official 2-letter USPS codes.`);
            return false;
        }
    }

    const minAGL = parseInt(document.getElementById('minAGL').value);
    if (isNaN(minAGL) || minAGL < 0 || minAGL > 10000) {
        alert("Minimum obstacle height must be between 0 and 10,000 ft AGL.");
        return false;
    }

    const ringNM = parseFloat(document.getElementById('ringNM').value);
    if (isNaN(ringNM) || ringNM < 0.1 || ringNM > 10.0) {
        alert("Ring radius around obstacles must be between 0.1 and 10.0 NM.");
        return false;
    }

    if (mode !== 'state') {
        const boundaryWidth = parseInt(document.getElementById('boundaryWidth').value);
        if (isNaN(boundaryWidth) || boundaryWidth < 1 || boundaryWidth > 10) {
            alert("Search boundary line thickness must be between 1 and 10 px.");
            return false;
        }
    }

    const ringWidth = parseInt(document.getElementById('ringWidth').value);
    if (isNaN(ringWidth) || ringWidth < 1 || ringWidth > 10) {
        alert("Obstacle ring line thickness must be between 1 and 10 px.");
        return false;
    }

    const notamMinAGL = parseInt(document.getElementById('notamMinAGL').value);
    if (isNaN(notamMinAGL) || notamMinAGL < 0 || notamMinAGL > 10000) {
        alert("NOTAM Minimum height must be between 0 and 10,000 ft AGL.");
        return false;
    }

    return true;
}

// --- SMART LOOKUP LOGIC ---
function getResolvedAirports(inputStr) {
    if (!inputStr) return [];
    const ids = inputStr.split(',').map(s => s.trim().toUpperCase()).filter(s => s.length > 0);
    const resolved = [];
    
    for (const id of ids) {
        let apt = globalAirports[id];
        if (!apt && id.length === 4 && id.startsWith('K')) {
            apt = globalAirports[id.substring(1)];
        }
        if (apt) resolved.push({ ...apt, requestedId: id });
    }
    return resolved;
}

function updateFacilityName() {
    const val = document.getElementById('faaId').value;
    const apts = getResolvedAirports(val);
    const nameDiv = document.getElementById('facilityName');
    
    if (apts.length > 0) {
        const names = apts.map(a => a.name || a.requestedId).join(', ');
        nameDiv.innerText = `Centerpoint(s) set to ${names}`;
        nameDiv.style.color = "var(--success)";
    } else if (val.trim().length > 0) {
        nameDiv.innerText = "Identifier(s) not found.";
        nameDiv.style.color = "var(--danger)";
    } else {
        nameDiv.innerText = "";
    }
    triggerCounterUpdate();
}

// --- MATH & COORDINATE RESOLUTION ---
function getCenterCoords() {
    const mode = document.querySelector('input[name="centerMode"]:checked').value;
    if (mode === 'state') return [];

    if (mode === 'faa' || mode === 'route') {
        const apts = getResolvedAirports(document.getElementById('faaId').value);
        if (apts.length === 0) return null;
        return apts.map(a => ({ lat: a.lat, lon: a.lon, id: a.requestedId }));
    } else {
        return [{ 
            lat: parseFloat(document.getElementById('lat').value), 
            lon: parseFloat(document.getElementById('lon').value),
            id: 'CUSTOM'
        }];
    }
}

function hexToKmlColor(hex, opacityHex) {
    hex = hex.replace('#', '');
    const r = hex.substring(0, 2);
    const g = hex.substring(2, 4);
    const b = hex.substring(4, 6);
    return `${opacityHex}${b}${g}${r}`; 
}

function haversineNM(lat1, lon1, lat2, lon2) {
    const R = 3440.065; 
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
              Math.sin(dLon/2) * Math.sin(dLon/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
}

function bearing(lat1, lon1, lat2, lon2) {
    const lat1Rad = lat1 * Math.PI / 180;
    const lat2Rad = lat2 * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const y = Math.sin(dLon) * Math.cos(lat2Rad);
    const x = Math.cos(lat1Rad) * Math.sin(lat2Rad) - Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLon);
    return Math.atan2(y, x);
}

function pointToSegmentDistanceNM(lat, lon, lat1, lon1, lat2, lon2) {
    const R = 3440.065; 
    const d13 = haversineNM(lat1, lon1, lat, lon) / R; // Start to Obstacle
    const d12 = haversineNM(lat1, lon1, lat2, lon2) / R; // Start to End
    const d23 = haversineNM(lat2, lon2, lat, lon) / R; // End to Obstacle

    if (d12 === 0) return d13 * R;

    const theta13 = bearing(lat1, lon1, lat, lon);
    const theta12 = bearing(lat1, lon1, lat2, lon2);
    const theta23 = bearing(lat2, lon2, lat, lon);
    const theta21 = bearing(lat2, lon2, lat1, lon1);

    // If the angle is obtuse, the obstacle is "behind" the start point
    if (Math.cos(theta13 - theta12) < 0) return d13 * R;
    
    // If the angle is obtuse, the obstacle is "ahead" of the end point
    if (Math.cos(theta23 - theta21) < 0) return d23 * R;

    // Otherwise, calculate perpendicular cross-track distance
    const dxt = Math.asin(Math.sin(d13) * Math.sin(theta13 - theta12));
    return Math.abs(dxt) * R;
}

function generateCircleCoords(lat, lon, radiusNM) {
    const coords = [];
    const earthRadiusNM = 3440.065; 
    const dRad = radiusNM / earthRadiusNM;
    const latRad = lat * Math.PI / 180;
    const lonRad = lon * Math.PI / 180;

    for (let i = 0; i <= 36; i++) {
        const angle = (i === 36 ? 0 : i) / 36.0 * 2 * Math.PI;
        const newLatRad = Math.asin(Math.sin(latRad) * Math.cos(dRad) + Math.cos(latRad) * Math.sin(dRad) * Math.cos(angle));
        const newLonRad = lonRad + Math.atan2(Math.sin(angle) * Math.sin(dRad) * Math.cos(latRad), Math.cos(dRad) - Math.sin(latRad) * Math.sin(newLatRad));
        coords.push(`${newLonRad * 180 / Math.PI},${newLatRad * 180 / Math.PI},0`);
    }
    return coords.join(" ");
}

function destPointNM(lat, lon, brngRad, dNM) {
    const R = 3440.065;
    const dRad = dNM / R;
    const latRad = lat * Math.PI / 180;
    const lonRad = lon * Math.PI / 180;

    const newLatRad = Math.asin(Math.sin(latRad)*Math.cos(dRad) + Math.cos(latRad)*Math.sin(dRad)*Math.cos(brngRad));
    const newLonRad = lonRad + Math.atan2(Math.sin(brngRad)*Math.sin(dRad)*Math.cos(latRad), Math.cos(dRad)-Math.sin(latRad)*Math.sin(newLatRad));
    
    return { lat: newLatRad * 180 / Math.PI, lon: newLonRad * 180 / Math.PI };
}

function generateSegmentPolygon(lat1, lon1, lat2, lon2, radiusNM) {
    const brng = bearing(lat1, lon1, lat2, lon2);
    // Perpendicular offsets (+/- 90 degrees)
    const leftAngle = brng - Math.PI/2;
    const rightAngle = brng + Math.PI/2;

    const p1 = destPointNM(lat1, lon1, leftAngle, radiusNM);
    const p2 = destPointNM(lat2, lon2, leftAngle, radiusNM);
    const p3 = destPointNM(lat2, lon2, rightAngle, radiusNM);
    const p4 = destPointNM(lat1, lon1, rightAngle, radiusNM);

    // Return closed polygon ring coordinates for KML
    return `${p1.lon},${p1.lat},0 ${p2.lon},${p2.lat},0 ${p3.lon},${p3.lat},0 ${p4.lon},${p4.lat},0 ${p1.lon},${p1.lat},0`;
}

// --- KML GENERATOR ---
async function generateKML() {
    if (!validateInputs()) return;
    
    const mode = document.querySelector('input[name="centerMode"]:checked').value;
    const centers = getCenterCoords();
    if (!centers && mode !== 'state') return;
    
    let targetStates = [];
    if (mode === 'state') {
        const rawStates = document.getElementById('stateIds').value;
        targetStates = rawStates.split(',').map(s => s.trim().toUpperCase()).filter(s => s.length === 2);
    }
    
    const searchRadiusNM = mode !== 'state' ? parseFloat(document.getElementById('radiusNM').value) : 0;
    const minAGL = parseInt(document.getElementById('minAGL').value);
    
    // Standard Obstacle Setup
    const ringRadiusNM = parseFloat(document.getElementById('ringNM').value); 
    const isFilled = document.getElementById('enableFill').checked;
    const opacityPercent = isFilled ? parseInt(document.getElementById('fillOpacity').value) : 0;
    const opacityHex = Math.round((opacityPercent / 100) * 255).toString(16).padStart(2, '0');
    const outlineOpacityPercent = parseInt(document.getElementById('outlineOpacity').value);
    const outlineOpacityHex = Math.round((outlineOpacityPercent / 100) * 255).toString(16).padStart(2, '0');
    const ringWidth = document.getElementById('ringWidth').value;
    const outlineColor = hexToKmlColor(document.getElementById('outlineColor').value, outlineOpacityHex);
    const fillColor = hexToKmlColor(document.getElementById('fillColor').value, opacityHex);
    const enableFill = isFilled ? '1' : '0';

    // NOTAM Setup
    const incNotam = document.getElementById('notamInclude').checked;
    const notamMinAGL = parseInt(document.getElementById('notamMinAGL').value) || 0;
    const notamRingNM = parseFloat(document.getElementById('notamRingNM').value);
    const notamWidth = document.getElementById('notamRingWidth').value;
    const notamOutlineOpacityPercent = parseInt(document.getElementById('notamOutlineOpacity').value);
    const notamOutlineOpacityHex = Math.round((notamOutlineOpacityPercent / 100) * 255).toString(16).padStart(2, '0');
    const notamOutlineColor = hexToKmlColor(document.getElementById('notamOutlineColor').value, notamOutlineOpacityHex);
    const notamEnableFillRaw = document.getElementById('notamEnableFill').checked;
    const notamOpacPercent = notamEnableFillRaw ? parseInt(document.getElementById('notamFillOpacity').value) : 0;
    const notamOpacityHex = Math.round((notamOpacPercent / 100) * 255).toString(16).padStart(2, '0');
    const notamFillColor = hexToKmlColor(document.getElementById('notamFillColor').value, notamOpacityHex);
    const notamEnableFill = notamEnableFillRaw ? '1' : '0';

    const boundaryWidth = mode !== 'state' ? document.getElementById('boundaryWidth').value : 2;
    const enableBoundary = document.getElementById('enableBoundary').checked;
    const boundaryOpacityPercent = parseInt(document.getElementById('boundaryLineOpacity').value);
    const boundaryOpacityHex = Math.round((boundaryOpacityPercent / 100) * 255).toString(16).padStart(2, '0');
    const boundaryColorHex = hexToKmlColor(document.getElementById('boundaryColor').value, boundaryOpacityHex);

    try {
        const obstacles = await getObstacles();

        let centerLabel = "CustomCoords";
        if (mode === 'state') {
            centerLabel = targetStates.join('-');
        } else if (mode === 'faa') {
            centerLabel = centers.map(c => c.id).join('-');
            if (centerLabel.length > 30) centerLabel = centerLabel.substring(0, 30) + '...';
        } else {
            const latLabel = parseFloat(document.getElementById('lat').value).toFixed(2);
            const lonLabel = parseFloat(document.getElementById('lon').value).toFixed(2);
            centerLabel = `${latLabel}_${lonLabel}`;
        }
        
        let kml = `<?xml version="1.0" encoding="UTF-8"?>\n<kml xmlns="http://www.opengis.net/kml/2.2">\n<Document>\n`;
        if (mode === 'state') {
            kml += `\t<name>${centerLabel} obstacles > ${minAGL} AGL</name>\n`;
        } else {
            kml += `\t<name>${centerLabel} obstacles > ${minAGL} AGL within ${searchRadiusNM}NM</name>\n`;
        }
        
        if (enableBoundary && mode !== 'state') {
            kml += `\t<Style id="boundaryStyle">\n\t\t<LineStyle>\n\t\t\t<color>${boundaryColorHex}</color>\n\t\t\t<width>${boundaryWidth}</width>\n\t\t</LineStyle>\n\t\t<PolyStyle>\n\t\t\t<fill>0</fill>\n\t\t</PolyStyle>\n\t</Style>\n`;
            
            // Draw circles at all waypoints (caps/joints)
            centers.forEach(c => {
                const boundaryCoords = generateCircleCoords(c.lat, c.lon, searchRadiusNM);
                kml += `\t<Placemark>\n\t\t<name>Search Area Boundary (${c.id} - ${searchRadiusNM} NM)</name>\n\t\t<styleUrl>#boundaryStyle</styleUrl>\n`;
                kml += `\t\t<Polygon>\n\t\t\t<outerBoundaryIs>\n\t\t\t\t<LinearRing>\n\t\t\t\t\t<coordinates>\n\t\t\t\t\t\t${boundaryCoords}\n\t\t\t\t\t</coordinates>\n\t\t\t\t</LinearRing>\n\t\t\t</outerBoundaryIs>\n\t\t</Polygon>\n\t</Placemark>\n`;
            });

            // Draw connecting corridor segments
            if (mode === 'route' && centers.length > 1) {
                for (let j = 0; j < centers.length - 1; j++) {
                    const segCoords = generateSegmentPolygon(centers[j].lat, centers[j].lon, centers[j+1].lat, centers[j+1].lon, searchRadiusNM);
                    kml += `\t<Placemark>\n\t\t<name>Corridor Segment (${centers[j].id} to ${centers[j+1].id})</name>\n\t\t<styleUrl>#boundaryStyle</styleUrl>\n`;
                    kml += `\t\t<Polygon>\n\t\t\t<outerBoundaryIs>\n\t\t\t\t<LinearRing>\n\t\t\t\t\t<coordinates>\n\t\t\t\t\t\t${segCoords}\n\t\t\t\t\t</coordinates>\n\t\t\t\t</LinearRing>\n\t\t\t</outerBoundaryIs>\n\t\t</Polygon>\n\t</Placemark>\n`;
                }
            }
        }        
        kml += `\t<Style id="customCircle">\n\t\t<LineStyle>\n\t\t\t<color>${outlineColor}</color>\n\t\t\t<width>${ringWidth}</width>\n\t\t</LineStyle>\n`;
        kml += `\t\t<PolyStyle>\n\t\t\t<color>${fillColor}</color>\n\t\t\t<fill>${enableFill}</fill>\n\t\t</PolyStyle>\n\t</Style>\n`;

        if (incNotam) {
            kml += `\t<Style id="notamCircle">\n\t\t<LineStyle>\n\t\t\t<color>${notamOutlineColor}</color>\n\t\t\t<width>${notamWidth}</width>\n\t\t</LineStyle>\n`;
            kml += `\t\t<PolyStyle>\n\t\t\t<color>${notamFillColor}</color>\n\t\t\t<fill>${notamEnableFill}</fill>\n\t\t</PolyStyle>\n\t</Style>\n`;
        }

        const incStd = document.getElementById('stdInclude').checked;
        
        if (incStd) {
            obstacles.forEach(obs => {
                if (obs.agl > minAGL) {
                    let keep = false;
                    
                    if (mode === 'state') {
                        if (obs.state && targetStates.includes(obs.state)) keep = true;
                    } else if (mode === 'route' && centers.length > 1) {
                        for (let j = 0; j < centers.length - 1; j++) {
                            if (pointToSegmentDistanceNM(obs.lat, obs.lon, centers[j].lat, centers[j].lon, centers[j+1].lat, centers[j+1].lon) <= searchRadiusNM) {
                                keep = true;
                                break;
                            }
                        }
                    } else {
                        for (const c of centers) {
                            if (haversineNM(c.lat, c.lon, obs.lat, obs.lon) <= searchRadiusNM) {
                                keep = true;
                                break;
                            }
                        }
                    }

                    if (keep) {
                        const circleCoords = generateCircleCoords(obs.lat, obs.lon, ringRadiusNM);
                        kml += `\t<Placemark>\n\t\t<name>${obs.city} (${obs.id}) - ${obs.agl} AGL</name>\n\t\t<styleUrl>#customCircle</styleUrl>\n`;
                        kml += `\t\t<Polygon>\n\t\t\t<outerBoundaryIs>\n\t\t\t\t<LinearRing>\n\t\t\t\t\t<coordinates>\n\t\t\t\t\t\t${circleCoords}\n\t\t\t\t\t</coordinates>\n\t\t\t\t</LinearRing>\n\t\t\t</outerBoundaryIs>\n\t\t</Polygon>\n\t</Placemark>\n`;
                    }
                }
            });
        }

        // OPTIMIZATION: Pre-filter state obstacles for KML generation
        let stateObstacles = [];
        if (mode === 'state' && targetStates.length > 0) {
            stateObstacles = obstacles.filter(o => targetStates.includes(o.state));
        }

        if (incNotam && globalNotams) {
            globalNotams.forEach(notam => {
            let keep = false;
                if (mode === 'state') {
                    if (targetStates.length > 0) {
                        for (let k = 0; k < stateObstacles.length; k++) {
                            if (Math.abs(stateObstacles[k].lat - notam.lat) < 0.02 && Math.abs(stateObstacles[k].lon - notam.lon) < 0.02) {
                                if (haversineNM(stateObstacles[k].lat, stateObstacles[k].lon, notam.lat, notam.lon) <= 1.0) {
                                    keep = true;
                                    break;
                                }
                            }
                        }
                    }
                } else if (mode === 'route' && centers.length > 1) {
                    for (let j = 0; j < centers.length - 1; j++) {
                        if (pointToSegmentDistanceNM(notam.lat, notam.lon, centers[j].lat, centers[j].lon, centers[j+1].lat, centers[j+1].lon) <= searchRadiusNM) {
                            keep = true;
                            break;
                        }
                    }
                } else {
                    for (const c of centers) {
                        if (haversineNM(c.lat, c.lon, notam.lat, notam.lon) <= searchRadiusNM) {
                            keep = true;
                            break;
                        }
                    }
                }

                if (keep) {
                    let finalAgl = parseNotamAGL(notam.text, notam.agl);
                    let aglNum = parseFloat(finalAgl); 
                    if (!isNaN(aglNum) && aglNum < notamMinAGL) {
                        keep = false;
                    }

                    if (keep) {
                        const circleCoords = generateCircleCoords(notam.lat, notam.lon, notamRingNM);
                        kml += `\t<Placemark>\n\t\t<name>UNLIT TOWER - ${finalAgl} ft AGL</name>\n`;
                        kml += `\t\t<description><![CDATA[${notam.text}]]></description>\n`;
                        kml += `\t\t<styleUrl>#notamCircle</styleUrl>\n`;
                        kml += `\t\t<Polygon>\n\t\t\t<outerBoundaryIs>\n\t\t\t\t<LinearRing>\n\t\t\t\t\t<coordinates>\n\t\t\t\t\t\t${circleCoords}\n\t\t\t\t\t</coordinates>\n\t\t\t\t</LinearRing>\n\t\t\t</outerBoundaryIs>\n\t\t</Polygon>\n\t</Placemark>\n`;
                    }
                }
            });
        }

        kml += `</Document>\n</kml>`;
        
        const now = new Date();
        const dtStr = now.getFullYear() + 
                      String(now.getMonth() + 1).padStart(2, '0') + 
                      String(now.getDate()).padStart(2, '0') + "-" + 
                      String(now.getHours()).padStart(2, '0') + 
                      String(now.getMinutes()).padStart(2, '0');

        const radiusStr = mode === 'state' ? "STATE" : `${searchRadiusNM}NM`;
        
        const rawCustomName = document.getElementById('customFileName').value.trim();
        // Clean out characters that are illegal in standard OS filenames
        const customName = rawCustomName.replace(/[<>:"/\\|?*]/g, ''); 
        const formatStyle = document.getElementById('fileNameFormat').value;
        const baseName = customName || `Obstacles-${centerLabel}`;
        
        let finalFilename = `${baseName}.kml`;
        if (formatStyle === 'standard') {
            finalFilename = `${baseName}_${minAGL}AGL.kml`;
        } else if (formatStyle === 'verbose') {
            finalFilename = `${baseName}-${minAGL}AGL-${radiusStr}-${dtStr}.kml`;
        }

        const blob = new Blob([kml], { type: 'application/vnd.google-earth.kml+xml' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = finalFilename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
    } catch (error) {
        console.error("Error generating KML:", error);
        alert("Make sure you are running this on a web server so it can load the obstacles.json file!");
    }
}

// --- MAP PREVIEW INTEGRATION ---
let leafletMap = null, previewLayerGroup = null;
let layers = {}, activeBase = 'street';

async function showMapPreview() {
    if (!validateInputs()) return;
    
    const mode = document.querySelector('input[name="centerMode"]:checked').value;
    const centers = getCenterCoords();
    if (!centers && mode !== 'state') return;

    let targetStates = [];
    if (mode === 'state') {
        const rawStates = document.getElementById('stateIds').value;
        targetStates = rawStates.split(',').map(s => s.trim().toUpperCase()).filter(s => s.length === 2);
    }

    document.getElementById('mapOverlay').style.display = 'block';
    const loader = document.getElementById('loader');
    
    if (!leafletMap) {
        leafletMap = L.map('map', { zoomControl: false, attributionControl: false, preferCanvas: true }).setView([39.8, -98.5], 4);
        
        layers = {
            dark: L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', { maxZoom: 20 }),
            street: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(leafletMap),
            sat: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'),
            vfr: L.tileLayer('https://tiles.arcgis.com/tiles/ssFJjBXIUyZDrSYZ/arcgis/rest/services/VFR_Sectional/MapServer/tile/{z}/{y}/{x}', {maxZoom: 12})
        };

        previewLayerGroup = L.featureGroup().addTo(leafletMap);
    }
    
    leafletMap.invalidateSize(); 
    previewLayerGroup.clearLayers();
    loader.style.display = 'flex';

    const searchRadiusNM = mode !== 'state' ? parseFloat(document.getElementById('radiusNM').value) : 0;
    const minAGL = parseInt(document.getElementById('minAGL').value);
    
    const ringNM = parseFloat(document.getElementById('ringNM').value);
    const ringWidth = parseInt(document.getElementById('ringWidth').value) || 2;
    const isFilled = document.getElementById('enableFill').checked;
    const fillOpacFloat = isFilled ? (parseInt(document.getElementById('fillOpacity').value) / 100) : 0;
    const outlineOpacFloat = parseInt(document.getElementById('outlineOpacity').value) / 100;
    const outlineColor = document.getElementById('outlineColor').value;
    const fillColor = document.getElementById('fillColor').value;
    
    const incNotam = document.getElementById('notamInclude').checked;
    const notamMinAGL = parseInt(document.getElementById('notamMinAGL').value) || 0;
    const notamRingNM = parseFloat(document.getElementById('notamRingNM').value);
    const notamWidth = parseInt(document.getElementById('notamRingWidth').value) || 3;
    const notamFilled = document.getElementById('notamEnableFill').checked;
    const notamOpacFloat = notamFilled ? (parseInt(document.getElementById('notamFillOpacity').value) / 100) : 0;
    const notamOutlineOpacFloat = parseInt(document.getElementById('notamOutlineOpacity').value) / 100;
    const notamOutlineColor = document.getElementById('notamOutlineColor').value;
    const notamFillColor = document.getElementById('notamFillColor').value;

    const boundaryWidth = mode !== 'state' ? (parseInt(document.getElementById('boundaryWidth').value) || 2) : 2;
    const enableBoundary = document.getElementById('enableBoundary').checked;
    const boundaryColor = document.getElementById('boundaryColor').value;
    const boundaryOpacFloat = parseInt(document.getElementById('boundaryLineOpacity').value) / 100;

    if (enableBoundary && mode !== 'state') {
        // Draw circles at all waypoints
        centers.forEach(c => {
            L.circle([c.lat, c.lon], {
                radius: searchRadiusNM * 1852,
                color: boundaryColor,
                opacity: boundaryOpacFloat,
                fill: false,
                weight: boundaryWidth,
                dashArray: '5, 10'
            }).addTo(previewLayerGroup);
        });

        // Draw connecting corridor segments for Route Mode
        if (mode === 'route' && centers.length > 1) {
            for (let j = 0; j < centers.length - 1; j++) {
                const lat1 = centers[j].lat, lon1 = centers[j].lon;
                const lat2 = centers[j+1].lat, lon2 = centers[j+1].lon;
                
                const brng = bearing(lat1, lon1, lat2, lon2);
                const leftAngle = brng - Math.PI/2;
                const rightAngle = brng + Math.PI/2;
                
                const p1 = destPointNM(lat1, lon1, leftAngle, searchRadiusNM);
                const p2 = destPointNM(lat2, lon2, leftAngle, searchRadiusNM);
                const p3 = destPointNM(lat2, lon2, rightAngle, searchRadiusNM);
                const p4 = destPointNM(lat1, lon1, rightAngle, searchRadiusNM);

                L.polygon([
                    [p1.lat, p1.lon],
                    [p2.lat, p2.lon],
                    [p3.lat, p3.lon],
                    [p4.lat, p4.lon]
                ], {
                    color: boundaryColor,
                    opacity: boundaryOpacFloat,
                    fill: false,
                    weight: boundaryWidth,
                    dashArray: '5, 10'
                }).addTo(previewLayerGroup);
            }
        }
    }

    try {
        const obstacles = await getObstacles();

        const incStd = document.getElementById('stdInclude').checked;
        
        if (incStd) {
            obstacles.forEach(obs => {
                if (obs.agl > minAGL) {
                    let keep = false;
                    
                    if (mode === 'state') {
                        if (obs.state && targetStates.includes(obs.state)) keep = true;
                    } else if (mode === 'route' && centers.length > 1) {
                        for (let j = 0; j < centers.length - 1; j++) {
                            if (pointToSegmentDistanceNM(obs.lat, obs.lon, centers[j].lat, centers[j].lon, centers[j+1].lat, centers[j+1].lon) <= searchRadiusNM) {
                                keep = true;
                                break;
                            }
                        }
                    } else {
                        for (const c of centers) {
                            if (haversineNM(c.lat, c.lon, obs.lat, obs.lon) <= searchRadiusNM) {
                                keep = true;
                                break;
                            }
                        }
                    }

                    if (keep) {
                        L.circle([obs.lat, obs.lon], {
                            radius: ringNM * 1852,
                            color: outlineColor,
                            opacity: outlineOpacFloat,
                            fillColor: fillColor,
                            fillOpacity: fillOpacFloat,
                            weight: ringWidth
                        }).bindPopup(`<b>${obs.city} (${obs.id})</b><br>${obs.agl} ft AGL`)
                          .addTo(previewLayerGroup);
                    }
                }
            });
        }

	// OPTIMIZATION: Pre-filter state obstacles for Map Preview
        let stateObstacles = [];
        if (mode === 'state' && targetStates.length > 0) {
            stateObstacles = obstacles.filter(o => targetStates.includes(o.state));
        }

        if (incNotam && globalNotams) {
            globalNotams.forEach(notam => {
            let keep = false;
                if (mode === 'state') {
                    if (targetStates.length > 0) {
                        for (let k = 0; k < stateObstacles.length; k++) {
                            if (Math.abs(stateObstacles[k].lat - notam.lat) < 0.02 && Math.abs(stateObstacles[k].lon - notam.lon) < 0.02) {
                                if (haversineNM(stateObstacles[k].lat, stateObstacles[k].lon, notam.lat, notam.lon) <= 1.0) {
                                    keep = true;
                                    break;
                                }
                            }
                        }
                    }
                } else if (mode === 'route' && centers.length > 1) {
                    for (let j = 0; j < centers.length - 1; j++) {
                        if (pointToSegmentDistanceNM(notam.lat, notam.lon, centers[j].lat, centers[j].lon, centers[j+1].lat, centers[j+1].lon) <= searchRadiusNM) {
                            keep = true;
                            break;
                        }
                    }
                } else {
                    for (const c of centers) {
                        if (haversineNM(c.lat, c.lon, notam.lat, notam.lon) <= searchRadiusNM) {
                            keep = true;
                            break;
                        }
                    }
                }

                if (keep) {
                    let finalAgl = parseNotamAGL(notam.text, notam.agl);
                    let aglNum = parseFloat(finalAgl); // FIX: parseFloat to retain decimals!
                    if (!isNaN(aglNum) && aglNum < notamMinAGL) {
                        keep = false;
                    }

                    if (keep) {
                        L.circle([notam.lat, notam.lon], {
                            radius: notamRingNM * 1852,
                            color: notamOutlineColor,
                            opacity: notamOutlineOpacFloat,
                            fillColor: notamFillColor,
                            fillOpacity: notamOpacFloat,
                            weight: notamWidth
                        }).bindPopup(`<b>UNLIT TOWER - ${finalAgl} ft AGL</b><br><span style="color:var(--danger); font-size:10px; font-weight:bold;">${notam.text}</span>`)
                          .addTo(previewLayerGroup);
                    }
                }
            });
        }

        if (previewLayerGroup.getLayers().length > 0) {
            leafletMap.fitBounds(previewLayerGroup.getBounds(), {padding: [20, 20], maxZoom: 10});
        } else if (centers && centers.length > 0) {
            leafletMap.setView([centers[0].lat, centers[0].lon], 8);
        }

        loader.style.display = 'none';

    } catch (error) {
        loader.style.display = 'none';
        alert("Map Preview Error: Could not load obstacles.json.");
    }
}

function hideMap() { document.getElementById('mapOverlay').style.display = 'none'; }
function toggleMaximize() { document.getElementById('mapOverlay').classList.toggle('maximized'); setTimeout(() => leafletMap.invalidateSize(), 400); }

function setBaseView(type) {
    if (layers[activeBase]) leafletMap.removeLayer(layers[activeBase]);
    layers[type].addTo(leafletMap).bringToBack();
    activeBase = type;

    document.querySelectorAll('.layer-switch .layer-btn').forEach(b => b.classList.remove('active'));
    document.getElementById('b-' + type).classList.add('active');
}

// --- PROFILE SAVE/LOAD & RESET LOGIC ---

// Cache the initial default state of the page instantly on load
const defaultProfileState = {};
document.querySelectorAll('input[id], select[id]').forEach(el => {
    if (el.type === 'file') return;
    defaultProfileState[el.id] = el.type === 'checkbox' || el.type === 'radio' ? el.checked : el.value;
});

function saveProfile() {
    const profile = {};
    document.querySelectorAll('input[id], select[id]').forEach(el => {
        if (el.type === 'file') return;
        profile[el.id] = el.type === 'checkbox' || el.type === 'radio' ? el.checked : el.value;
    });
    
    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(profile, null, 2));
    const dlAnchorElem = document.createElement('a');
    
    const now = new Date();
    const dtStr = now.getFullYear() + String(now.getMonth() + 1).padStart(2, '0') + String(now.getDate()).padStart(2, '0');
    const customName = document.getElementById('customFileName').value.trim().replace(/[<>:"/\\|?*]/g, '') || "Profile";
    
    dlAnchorElem.setAttribute("href", dataStr);
    dlAnchorElem.setAttribute("download", `KML_Settings_${customName}_${dtStr}.json`);
    document.body.appendChild(dlAnchorElem);
    dlAnchorElem.click();
    document.body.removeChild(dlAnchorElem);
}

function applyProfileState(profile) {
    for (const key in profile) {
        const el = document.getElementById(key);
        if (el && el.type !== 'file') {
            if (el.type === 'checkbox' || el.type === 'radio') {
                el.checked = profile[key];
            } else {
                el.value = profile[key];
            }
        }
    }
    
    // Sync the new range sliders with the loaded text box values
    if (document.getElementById('searchNMSlider')) document.getElementById('searchNMSlider').value = document.getElementById('radiusNM').value;
    if (document.getElementById('ringNMSlider')) document.getElementById('ringNMSlider').value = document.getElementById('ringNM').value;
    if (document.getElementById('notamRingNMSlider')) document.getElementById('notamRingNMSlider').value = document.getElementById('notamRingNM').value;

    // Programmatically trigger all UI update functions
    toggleCenterInput(true);
    updateOpacityLabel();
    toggleOpacitySlider();
    updateNotamOpacityLabel();
    toggleNotamOpacitySlider();
    updateOutlineOpacityLabel();
    updateNotamOutlineOpacityLabel();
    updateBoundaryOpacityLabel();
    toggleBoundaryOpacitySlider();
    updateStdRingColor();
    updateNotamRingColor();
    checkAGLWarning();
    toggleLayerOptions();
}

function loadProfile(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const profile = JSON.parse(e.target.result);
            applyProfileState(profile);
            event.target.value = ""; // Reset file input to allow reloading the same file
        } catch (err) {
            console.error("Profile Load Error:", err);
            alert("Failed to load profile. Ensure the file is a valid JSON generated by this tool.");
        }
    };
    reader.readAsText(file);
}

function resetToDefaults() {
    applyProfileState(defaultProfileState);
}
</script>
</body>
</html>